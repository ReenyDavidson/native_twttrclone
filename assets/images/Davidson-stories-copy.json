{"posts":[{"reward":{"type":"xlm"},"sourcedFromGithub":false,"isAnonymous":false,"views":55,"slugOverridden":false,"coverImage":"https://cdn.hashnode.com/res/hashnode/image/upload/v1615399390044/iwym2NvZO.jpeg","autoGeneratedCover":"","brief":"Hello there, I would like to walk you through the process of building a basic to-do list in react-native. Before I begin, here is a snippet of what we will be building in this article.\n\nYou should have a  basic knowledge of React and how it works bef...","content":"<p>Hello there, I would like to walk you through the process of building a basic to-do list in react-native. Before I begin, here is a snippet of what we will be building in this article.</p>\n<p><img src=\"https://cdn.hashnode.com/res/hashnode/image/upload/v1615399383953/WWfzAo0MB.jpeg\" alt=\"Alt Text\" /><img src=\"https://cdn.hashnode.com/res/hashnode/image/upload/v1615399387192/_mHnITfpv.jpeg\" alt=\"Alt Text\" /></p>\n<p>You should have a  basic knowledge of React and how it works before engaging this article, as I would not be explaining some of these basic concepts</p>\n<p><strong>Getting Started</strong>\nWe would start by using Expo to create or initialize a new app from the command line. This app is created by Expo and a boilerplate on which we will be building our to-do app. </p>\n<pre><code>$ expo init todo-list\n\n$ cd todo-list\n\n$ expo start\n</code></pre><p>In the code above, an app called todo-list is created, then we change the directory to the todo-list folder that was created and start the app with the 'expo start' command. Go now to the App.js file and delete all the code there. Don't worry, we will write our own code, which is much better than what is already there. Now we have set up our environment, we can begin building.</p>\n<p>Are you ready bud? </p>\n<p>Sure you are.</p>\n<p><strong>Creating Components</strong></p>\n<p>Let's begin by creating a folder called Components, which will hold four files. These files are components that are serving different purposes. We will call these components AddInput.js, Header.js, Empty.js, and TodoList.js. These components will be the main attributes of our work here. </p>\n<p>In AddInput.js we should have something like this:</p>\n<pre><code class=\"lang-javascript\"><span class=\"hljs-comment\">//AddInput.js</span>\n\n<span class=\"hljs-keyword\">import</span> React, { useState } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"react\"</span>;\n<span class=\"hljs-keyword\">import</span> {View, TextInput, Text, TouchableOpacity} <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'react-native'</span>\n\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">AddInput</span>(<span class=\"hljs-params\"></span>) </span>{\n  <span class=\"hljs-keyword\">const</span> [value, setValue] = useState(<span class=\"hljs-string\">\"\"</span>);\n\n  <span class=\"hljs-keyword\">const</span> onChangeText = <span class=\"hljs-function\">(<span class=\"hljs-params\">text</span>) =&gt;</span> {\n    setValue(text);\n  };\n\n  <span class=\"hljs-keyword\">return</span> (\n    <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">View</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">View</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">TextInput</span> <span class=\"hljs-attr\">placeholder</span>=<span class=\"hljs-string\">\"Add Task...\"</span> <span class=\"hljs-attr\">onChangeText</span>= \n         <span class=\"hljs-string\">{onChangeText}</span> /&gt;</span>\n      <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">View</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">TouchableOpacity</span>\n        <span class=\"hljs-attr\">onPress</span>=<span class=\"hljs-string\">{()</span> =&gt;</span> {\n          alert('button clicked')\n        }}\n      &gt;\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Text</span>&gt;</span>Submit<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">Text</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">TouchableOpacity</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">View</span>&gt;</span></span>\n  );\n}\n</code></pre>\n<p>This gives us a basic form where we write to-do items and a button to add them to the to-do list. Let's give this guy a bit of styling to make it look good. </p>\n<p><strong>styling AddInput.js</strong>\nWe would be using a library called styled-components to style the component. Firstly, we install styled-components</p>\n<pre><code class=\"lang-javascript\">yarn add styled-components\n</code></pre>\n<p>After installing it, we import it into the AddInput.js file so we can be able to use it.</p>\n<pre><code class=\"lang-javascript\"><span class=\"hljs-comment\">//AddInput.js</span>\n ...\nimport styled <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"styled-components\"</span>;\n\n ...\n\n<span class=\"hljs-comment\">//beneath the AddInput component</span>\n<span class=\"hljs-comment\">//styles</span>\n<span class=\"hljs-keyword\">const</span> ComponentContainer = styled.View<span class=\"hljs-string\">`\n  flex-direction: row;\n`</span>;\n\n<span class=\"hljs-keyword\">const</span> InputContainer = styled.View<span class=\"hljs-string\">`\n  flex-direction: row;\n  border-radius: 10px;\n`</span>;\n\n<span class=\"hljs-keyword\">const</span> Input = styled.TextInput<span class=\"hljs-string\">`\n  font-size: 20px;\n  background-color: white;\n  width: 300px;\n  margin-right: 20px;\n  padding: 10px;\n  margin-bottom: 20px;\n  border-radius: 10px;\n`</span>;\n\n<span class=\"hljs-keyword\">const</span> SubmitButton = styled.TouchableOpacity<span class=\"hljs-string\">`\n  width: 50px;\n  justify-content: center;\n  align-items: center;\n  background-color: whitesmoke;\n  margin-bottom: 20px;\n  border-radius: 50px;\n`</span>;\n\n ...\n</code></pre>\n<p>In the AddInput component, we would now be updating the native components to custom semantics from styled-components. These native components will now be accessed via styled-components. This is to enable the styling to take place in the AddInput component.</p>\n<pre><code class=\"lang-javascript\"> ...\n\nexport <span class=\"hljs-keyword\">default</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">AddInput</span>(<span class=\"hljs-params\">}</span>) </span>{\n ...\n  return (\n    <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ComponentContainer</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">InputContainer</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Input</span> <span class=\"hljs-attr\">placeholder</span>=<span class=\"hljs-string\">\"Add Task...\"</span> <span class=\"hljs-attr\">onChangeText</span>=<span class=\"hljs-string\">{onChangeText}</span> /&gt;</span>\n      <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">InputContainer</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">SubmitButton</span>\n        <span class=\"hljs-attr\">onPress</span>=<span class=\"hljs-string\">{()</span> =&gt;</span> {\n           alert('button clicked')\n        }}\n      &gt;\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Text</span>&gt;</span>Submit<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">Text</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">SubmitButton</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">ComponentContainer</span>&gt;</span></span>\n  );\n}\n\n<span class=\"hljs-comment\">//beneath the AddInput component</span>\n<span class=\"hljs-comment\">//styles</span>\n\n ...\n</code></pre>\n<p>As you can see, we updated the native components to a custom-styled component. In this case, we would not need to import these native components from react-native anymore as styled-components already let us access them. </p>\n<p>Alright, that's enough for the AddInput.js for now. Let's quickly build up the Empty.js before we continue. The Empty.js file is rendered when the to-do list is empty. This component kind of makes the app look more appealing. </p>\n<pre><code class=\"lang-javascript\"><span class=\"hljs-keyword\">import</span> React <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"react\"</span>;\n<span class=\"hljs-keyword\">import</span> styled <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"styled-components\"</span>;\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Empty</span>(<span class=\"hljs-params\"></span>) </span>{\n  <span class=\"hljs-keyword\">return</span> (\n    <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ComponentContainer</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">EmptyImage</span>\n        <span class=\"hljs-attr\">source</span>=<span class=\"hljs-string\">{require(</span>\"<span class=\"hljs-attr\">add</span> <span class=\"hljs-attr\">an</span> <span class=\"hljs-attr\">image</span> <span class=\"hljs-attr\">here</span>\")}\n      /&gt;</span>\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">EmptyText</span>&gt;</span>Add To-Do.<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">EmptyText</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">ComponentContainer</span>&gt;</span></span>\n  );\n}\n\n<span class=\"hljs-keyword\">const</span> ComponentContainer = styled.View<span class=\"hljs-string\">`\n  align-items: center;\n  justify-content: center;\n  height: 650px;\n`</span>;\n\n<span class=\"hljs-keyword\">const</span> EmptyImage = styled.Image<span class=\"hljs-string\">`\n  width: 350px;\n  height: 200px;\n`</span>;\n\n<span class=\"hljs-keyword\">const</span> EmptyText = styled.Text<span class=\"hljs-string\">`\n  color: white;\n  font-family: poppins-bold;\n  margin-top: 30px;\n  font-size: 30px;\n`</span>;\n</code></pre>\n<p>Let's build what I consider the heartbeat of this app. This will happen in App.js</p>\n<pre><code class=\"lang-javascript\"><span class=\"hljs-keyword\">import</span> React, { useState } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"react\"</span>;\n<span class=\"hljs-keyword\">import</span> { View, StatusBar, FlatList } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"react-native\"</span>;\n<span class=\"hljs-keyword\">import</span> styled <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"styled-components\"</span>;\n\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">App</span>(<span class=\"hljs-params\"></span>) </span>{\n <span class=\"hljs-keyword\">const</span> [data, setData] = useState([]);\n <span class=\"hljs-keyword\">return</span> (\n      <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ComponentContainer</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">View</span>&gt;</span>\n          <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">StatusBar</span> <span class=\"hljs-attr\">barStyle</span>=<span class=\"hljs-string\">\"light-content\"</span> \n             <span class=\"hljs-attr\">backgroundColor</span>=<span class=\"hljs-string\">\"midnightblue\"</span> /&gt;</span>\n        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">View</span>&gt;</span>\n\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">View</span>&gt;</span>\n          <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">FlatList</span>\n            <span class=\"hljs-attr\">data</span>=<span class=\"hljs-string\">{data}</span>\n           <span class=\"hljs-attr\">renderItem</span>=<span class=\"hljs-string\">{({</span> <span class=\"hljs-attr\">item</span> }) =&gt;</span> (\n              console.log(item)\n            )}\n          /&gt;\n\n        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">View</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">ComponentContainer</span>&gt;</span></span>\n    );\n}\n\n<span class=\"hljs-keyword\">const</span> ComponentContainer = styled.View<span class=\"hljs-string\">`\n  background-color: midnightblue;\n  height: 100%;\n  flex-direction: column;\n  align-items: center;\n  justify-content: center;\n`</span>;\n</code></pre>\n<p><strong>FlatList</strong></p>\n<p>At this point, I want to let you know that a to-do list is an array. Let me explain that with something called FlatList. FlatList is a component used to display large scrollable lists. Lists displayed with the FlatList can be infinite and unpredictable. FlatList has two major props which include <strong>data</strong> and the <strong>renderItem</strong>. <strong>data</strong> takes an array, in this case, an array called data which is an empty array and depends on the AddInput component for data to fill up the empty array. This array is the to-do list. On the other hand, we have the <strong>renderItem</strong>  which is a callback function that renders each item of the array of the <strong>data</strong> prop. </p>\n<p>##<strong>Adding item to the list</strong>##</p>\n<p>Let us go back to our AddInput component and look at one of the native components called TouchableOpacity. This component takes in a prop called onPress. If you check out our above code on AddInput.js, you will see that the onPress prop is set to alert('hi') . onPress runs a function when a button is pressed. Now, the function it will be running is the one that will be adding items to the list(array called data). </p>\n<p>In App.js we will create a method called SubmitHandler, which adds each item to the list. This is the function that will be passed into onPress. </p>\n<pre><code class=\"lang-javascript\"><span class=\"hljs-comment\">//App.js</span>\n  ...\n\nexport <span class=\"hljs-keyword\">default</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">App</span>(<span class=\"hljs-params\"></span>) </span>{\n     ...\n  const submitHandler = <span class=\"hljs-function\">(<span class=\"hljs-params\">value</span>) =&gt;</span> {\n    setData(<span class=\"hljs-function\">(<span class=\"hljs-params\">prevTodo</span>) =&gt;</span> {\n      <span class=\"hljs-keyword\">return</span> [\n        {\n          <span class=\"hljs-attr\">value</span>: value,\n          <span class=\"hljs-attr\">key</span>: <span class=\"hljs-built_in\">Math</span>.random().toString(),\n        },\n        ...prevTodo,\n      ];\n    });\n\n     ...\n  };\n</code></pre>\n<p>The submitHandler method holds a function called setData that updates the state by adding items to the array.</p>\n<p>To get the SubmitHandler method to work in the AddInput.js, we need to bring the AddInput component into the App.js and pass the SubmitHandler as a prop to the AddInput component.</p>\n<pre><code class=\"lang-javascript\"><span class=\"hljs-comment\">//App.js</span>\n ...\nimport AddInput <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"./Components/AddInput\"</span>;\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">App</span>(<span class=\"hljs-params\"></span>) </span>{\n   ...\n\n  const submitHandler = <span class=\"hljs-function\">(<span class=\"hljs-params\">value</span>) =&gt;</span> {\n    setData(<span class=\"hljs-function\">(<span class=\"hljs-params\">prevTodo</span>) =&gt;</span> {\n      <span class=\"hljs-keyword\">return</span> [\n        {\n          <span class=\"hljs-attr\">value</span>: value,\n          <span class=\"hljs-attr\">key</span>: <span class=\"hljs-built_in\">Math</span>.random().toString(),\n        },\n        ...prevTodo,\n      ];\n    });\n  };\n\n\n    <span class=\"hljs-keyword\">return</span> (\n      <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ComponentContainer</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">View</span>&gt;</span>\n          <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">StatusBar</span> <span class=\"hljs-attr\">barStyle</span>=<span class=\"hljs-string\">\"light-content\"</span> \n            <span class=\"hljs-attr\">backgroundColor</span>=<span class=\"hljs-string\">\"midnightblue\"</span> /&gt;</span>\n        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">View</span>&gt;</span>\n\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">View</span>&gt;</span>\n          //FlatList\n          <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">View</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">AddInput</span> <span class=\"hljs-attr\">submitHandler</span>=<span class=\"hljs-string\">{submitHandler}</span> /&gt;</span>\n          <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">View</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">View</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">ComponentContainer</span>&gt;</span></span>\n    );\n</code></pre>\n<p>The submitHandler method is passed in as a prop to the AddInput component to be used inside the AddInput component. </p>\n<p>Back to AddInput.js, we pass in the props </p>\n<pre><code class=\"lang-javascript\">  ...\nexport <span class=\"hljs-keyword\">default</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">AddInput</span>(<span class=\"hljs-params\">{ submitHandler }</span>)</span>{\n   ...\nreturn(\n  ...\n &lt;SubmitButton\n        onPress={<span class=\"hljs-function\">() =&gt;</span> {\n          setValue(submitHandler(value));\n        }}\n      &gt;\n        ...\n      &lt;/SubmitButton&gt;\n)\n}\n</code></pre>\n<p>Here, we are adding the value from our form input to the array being handled by the <strong>data</strong> prop in App.js with the help of onPress who calls the SubmitHandler function when pressed.</p>\n<p><strong>Displaying list to screen</strong></p>\n<p>Another component called TodoList is created at this point because we need it to render our to-do list items to the screen. Remember the renderItems prop from FlatList which helps to render items from the data prop to the screen? We are going to use it to render the TodoList component to the screen(this component holds our array items.)</p>\n<p>Back to App.js</p>\n<pre><code class=\"lang-javascript\">  ...\nimport TodoList <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"./Components/TodoList\"</span>;\n  ...\n\n&lt;FlatList\n            data={data}\n            renderItem={<span class=\"hljs-function\">(<span class=\"hljs-params\">{ item }</span>) =&gt;</span> (\n              <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">TodoList</span> <span class=\"hljs-attr\">item</span>=<span class=\"hljs-string\">{item}</span> /&gt;</span></span>\n            )}\n          /&gt;\n</code></pre>\n<p>Now moving to the TodoList.js, we build our component. </p>\n<pre><code class=\"lang-javascript\"><span class=\"hljs-comment\">//TodoList.js</span>\n<span class=\"hljs-keyword\">import</span> React <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"react\"</span>;\n<span class=\"hljs-keyword\">import</span> { View } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"react-native\"</span>;\n<span class=\"hljs-keyword\">import</span> styled <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"styled-components\"</span>;\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">TodoList</span>(<span class=\"hljs-params\">{ item }</span>) </span>{\n  <span class=\"hljs-keyword\">return</span> (\n    <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ComponentContainer</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ListContainer</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">View</span>&gt;</span>\n          <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">TextItem</span>&gt;</span>{item.value}<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">TextItem</span>&gt;</span>\n          <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">TextTask</span>&gt;</span> Task<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">TextTask</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">View</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">ListContainer</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">ComponentContainer</span>&gt;</span></span>\n  );\n}\n\n<span class=\"hljs-keyword\">const</span> ListContainer = styled.TouchableOpacity<span class=\"hljs-string\">`\n  background-color: whitesmoke;\n  height: auto;\n  width: 350px;\n  margin-bottom: 30px;\n  border-radius: 10px;\n  flex-direction: row;\n  justify-content: space-between;\n`</span>;\n\n<span class=\"hljs-keyword\">const</span> ComponentContainer = styled.View<span class=\"hljs-string\">`\n  flex-direction: row;\n  justify-content: center;\n  height: auto;\n  width: auto;\n`</span>;\n\n<span class=\"hljs-keyword\">const</span> TextItem = styled.Text<span class=\"hljs-string\">`\n  color: black;\n  width: 260px;\n  height: auto;\n  font-size: 20px;\n  margin-top: 10px;\n  margin-right: 20px;\n  font-family: poppins-regular;\n`</span>;\n\n<span class=\"hljs-keyword\">const</span> TextTask = styled.Text<span class=\"hljs-string\">`\n  color: goldenrod;\n  font-size: 15px;\n  margin-right: 20px;\n  font-family: poppins-regular;\n  border-radius: 10px;\n  width: 40px;\n`</span>;\n</code></pre>\n<p>At this point, each item of our to-do list should be displayed on the screen when the function in onPress is called. </p>\n<p>Before we continue, we need to make our list of items unique with a key. We do this by employing a prop called the keyExtractor prop in FlatList. This prop assigns a key to each of the items in the list. </p>\n<pre><code class=\"lang-javascript\">  ...\n\n&lt;FlatList\n            data={data}\n            keyExtractor={<span class=\"hljs-function\">(<span class=\"hljs-params\">item</span>) =&gt;</span> item.key}\n            renderItem={<span class=\"hljs-function\">(<span class=\"hljs-params\">{ item }</span>) =&gt;</span> (\n              <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">TodoList</span> <span class=\"hljs-attr\">item</span>=<span class=\"hljs-string\">{item}</span> /&gt;</span></span>\n            )}\n          /&gt;\n</code></pre>\n<p><strong>Deleting items from list</strong></p>\n<p>To delete items from the to-do list, we will create a method called DeleteItem in App.js and bring it in as a prop into TodoList.js</p>\n<pre><code class=\"lang-javascript\"><span class=\"hljs-comment\">//App.js</span>\n  ...\n\nexport <span class=\"hljs-keyword\">default</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">App</span>(<span class=\"hljs-params\"></span>) </span>{\n     ...\n  const deleteItem = <span class=\"hljs-function\">(<span class=\"hljs-params\">key</span>) =&gt;</span> {\n    setData(<span class=\"hljs-function\">(<span class=\"hljs-params\">prevTodo</span>) =&gt;</span> {\n      <span class=\"hljs-keyword\">return</span> prevTodo.filter(<span class=\"hljs-function\">(<span class=\"hljs-params\">todo</span>) =&gt;</span> todo.key != key);\n    });\n  };\n     ...\n  };\n</code></pre>\n<p>Now we pass deleteItem as a prop to the TodoList component</p>\n<pre><code class=\"lang-javascript\"><span class=\"hljs-comment\">//App.js</span>\n  ...\nimport TodoList <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"./Components/TodoList\"</span>;\n  ...\n\n&lt;FlatList\n            data={data}\n            keyExtractor={<span class=\"hljs-function\">(<span class=\"hljs-params\">item</span>) =&gt;</span> item.key}\n            renderItem={<span class=\"hljs-function\">(<span class=\"hljs-params\">{ item }</span>) =&gt;</span> (\n              <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">TodoList</span> <span class=\"hljs-attr\">item</span>=<span class=\"hljs-string\">{item}</span> <span class=\"hljs-attr\">deleteItem</span>=<span class=\"hljs-string\">{deleteItem}</span> /&gt;</span></span>\n            )}\n          /&gt;\n</code></pre>\n<p>For DeleteItem to work in TodoList.js, we need to update the component. </p>\n<pre><code class=\"lang-javascript\"><span class=\"hljs-keyword\">import</span> React <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"react\"</span>;\n<span class=\"hljs-keyword\">import</span> { View } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"react-native\"</span>;\n<span class=\"hljs-keyword\">import</span> { Entypo } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"@expo/vector-icons\"</span>;\n<span class=\"hljs-keyword\">import</span> { MaterialIcons } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"@expo/vector-icons\"</span>;\n<span class=\"hljs-keyword\">import</span> styled <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"styled-components\"</span>;\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">TodoList</span>(<span class=\"hljs-params\">{ item, deleteItem }</span>) </span>{\n  <span class=\"hljs-keyword\">return</span> (\n    <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ComponentContainer</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ListContainer</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">CirlceContainer</span>&gt;</span>\n          <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Entypo</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"circle\"</span> <span class=\"hljs-attr\">size</span>=<span class=\"hljs-string\">{20}</span> <span class=\"hljs-attr\">color</span>=<span class=\"hljs-string\">\"midnightblue\"</span> /&gt;</span>\n        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">CirlceContainer</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">View</span>&gt;</span>\n          <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">TextItem</span>&gt;</span>{item.value}<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">TextItem</span>&gt;</span>\n          <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">TextDate</span>&gt;</span> Task<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">TextDate</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">View</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">IconContainer</span> <span class=\"hljs-attr\">onPress</span>=<span class=\"hljs-string\">{()</span> =&gt;</span> deleteItem(item.key)}&gt;\n          <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">MaterialIcons</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"delete\"</span> <span class=\"hljs-attr\">size</span>=<span class=\"hljs-string\">{24}</span> <span class=\"hljs-attr\">color</span>=<span class=\"hljs-string\">\"midnightblue\"</span> /&gt;</span>\n        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">IconContainer</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">ListContainer</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">ComponentContainer</span>&gt;</span></span>\n  );\n}\n\n<span class=\"hljs-keyword\">const</span> ListContainer = styled.TouchableOpacity<span class=\"hljs-string\">`\n  background-color: whitesmoke;\n  height: auto;\n  width: 350px;\n  margin-bottom: 30px;\n  border-radius: 10px;\n  flex-direction: row;\n  justify-content: space-between;\n`</span>;\n\n<span class=\"hljs-keyword\">const</span> ComponentContainer = styled.View<span class=\"hljs-string\">`\n  flex-direction: row;\n  justify-content: center;\n  height: auto;\n  width: auto;\n`</span>;\n\n<span class=\"hljs-keyword\">const</span> TextItem = styled.Text<span class=\"hljs-string\">`\n  color: black;\n  width: 260px;\n  height: auto;\n  font-size: 20px;\n  margin-top: 10px;\n  margin-right: 20px;\n  font-family: poppins-regular;\n`</span>;\n\n<span class=\"hljs-keyword\">const</span> TextDate = styled.Text<span class=\"hljs-string\">`\n  color: goldenrod;\n  font-size: 15px;\n  margin-right: 20px;\n\n  font-family: poppins-regular;\n  border-radius: 10px;\n  width: 40px;\n`</span>;\n\n<span class=\"hljs-keyword\">const</span> IconContainer = styled.TouchableOpacity<span class=\"hljs-string\">`\n  align-items: center;\n  justify-content: center;\n  margin-right: 10px;\n  margin-top: 15px;\n\n  height: 40px;\n\n  border-radius: 10px;\n`</span>;\n\n<span class=\"hljs-keyword\">const</span> CirlceContainer = styled.View<span class=\"hljs-string\">`\n  align-items: center;\n  justify-content: center;\n  padding-left: 5px;\n`</span>;\n</code></pre>\n<p>In the above code, we can delete an item from the list and we use icons to represent the delete button which removes items from the list when pressed.</p>\n<p><strong>Final Touches</strong></p>\n<p>The FlatList has other props attached to it. but we would focus on two more. These three include: \na. ListHeaderComponent\nb. ListEmptyComponent</p>\n<p>ListHeaderComponent will hold a component that contains the header of the list. Remember our Header.js file? It is time to use it. </p>\n<pre><code class=\"lang-javascript\"><span class=\"hljs-comment\">//Header.js</span>\n\n<span class=\"hljs-keyword\">import</span> React <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"react\"</span>;\n<span class=\"hljs-keyword\">import</span> styled <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"styled-components\"</span>;\n\n<span class=\"hljs-keyword\">let</span> today = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Date</span>().toISOString().slice(<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">10</span>);\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Header</span>(<span class=\"hljs-params\"></span>) </span>{\n  <span class=\"hljs-keyword\">return</span> (\n    <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ComponentContainer</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">HeaderText</span>&gt;</span>To-Do.<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">HeaderText</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">HeaderList</span>&gt;</span>{today}<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">HeaderList</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">ComponentContainer</span>&gt;</span></span>\n  );\n}\n\n<span class=\"hljs-keyword\">const</span> ComponentContainer = styled.View<span class=\"hljs-string\">`\n  height: 100px;\n  flex-direction: row;\n  justify-content: space-between;\n  align-items: center;\n`</span>;\n\n<span class=\"hljs-keyword\">const</span> HeaderText = styled.Text<span class=\"hljs-string\">`\n  color: white;\n  font-family: poppins-bold;\n  font-size: 30px;\n`</span>;\n\n<span class=\"hljs-keyword\">const</span> HeaderList = styled.Text<span class=\"hljs-string\">`\n  color: white;\n  font-family: poppins-bold;\n  font-size: 20px;\n  margin-right: 20px;\n`</span>;\n</code></pre>\n<p>This component will be at the head of the screen. Let's make some changes to our App.js file.</p>\n<pre><code class=\"lang-javascript\"><span class=\"hljs-comment\">//App.js</span>\n  ...\nimport Header <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"./Components/Header\"</span>;\n  ...\n\n&lt;FlatList\n            data={data}\n            ListHeaderComponent={<span class=\"hljs-function\">() =&gt;</span> <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Header</span> /&gt;</span></span>}\n            keyExtractor={<span class=\"hljs-function\">(<span class=\"hljs-params\">item</span>) =&gt;</span> item.key}\n            renderItem={<span class=\"hljs-function\">(<span class=\"hljs-params\">{ item }</span>) =&gt;</span> (\n              <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">TodoList</span> <span class=\"hljs-attr\">item</span>=<span class=\"hljs-string\">{item}</span> <span class=\"hljs-attr\">deleteItem</span>=<span class=\"hljs-string\">{deleteItem}</span> /&gt;</span></span>\n            )}\n          /&gt;\n</code></pre>\n<p>Another prop is the ListEmptyComponent which renders a component when the to-do list is empty. Here, we are going to pass in the Empty component from Empty.js</p>\n<pre><code class=\"lang-javascript\"><span class=\"hljs-comment\">//App.js</span>\n  ...\nimport Empty <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"./Components/Empty\"</span>;\n  ...\n\n&lt;FlatList\n            data={data}\n            ListHeaderComponent={<span class=\"hljs-function\">() =&gt;</span> <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Header</span> /&gt;</span></span>}\n            ListEmptyComponent={<span class=\"hljs-function\">() =&gt;</span> <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Empty</span> /&gt;</span></span>}\n            keyExtractor={<span class=\"hljs-function\">(<span class=\"hljs-params\">item</span>) =&gt;</span> item.key}\n            renderItem={<span class=\"hljs-function\">(<span class=\"hljs-params\">{ item }</span>) =&gt;</span> (\n              <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">TodoList</span> <span class=\"hljs-attr\">item</span>=<span class=\"hljs-string\">{item}</span> <span class=\"hljs-attr\">deleteItem</span>=<span class=\"hljs-string\">{deleteItem}</span> /&gt;</span></span>\n            )}\n          /&gt;\n</code></pre>\n<p><strong>Conclusion</strong></p>\n<p>Pheew! That was a lot of code. I hope you practice this and get your hands dirty. It is the best form of learning. I would love to see you tweak the code to your own taste and make something nice out of it. Good Luck in your endeavors and React-Native journey.</p>\n","contentMarkdown":"Hello there, I would like to walk you through the process of building a basic to-do list in react-native. Before I begin, here is a snippet of what we will be building in this article.\n\n![Alt Text](https://cdn.hashnode.com/res/hashnode/image/upload/v1615399383953/WWfzAo0MB.jpeg)![Alt Text](https://cdn.hashnode.com/res/hashnode/image/upload/v1615399387192/_mHnITfpv.jpeg)\n\nYou should have a  basic knowledge of React and how it works before engaging this article, as I would not be explaining some of these basic concepts\n\n \n**Getting Started**\nWe would start by using Expo to create or initialize a new app from the command line. This app is created by Expo and a boilerplate on which we will be building our to-do app. \n\n```\n$ expo init todo-list\n\n$ cd todo-list\n\n$ expo start\n\n```\n\nIn the code above, an app called todo-list is created, then we change the directory to the todo-list folder that was created and start the app with the 'expo start' command. Go now to the App.js file and delete all the code there. Don't worry, we will write our own code, which is much better than what is already there. Now we have set up our environment, we can begin building.\n\nAre you ready bud? \n\nSure you are.\n\n**Creating Components**\n\nLet's begin by creating a folder called Components, which will hold four files. These files are components that are serving different purposes. We will call these components AddInput.js, Header.js, Empty.js, and TodoList.js. These components will be the main attributes of our work here. \n\nIn AddInput.js we should have something like this:\n\n```javascript\n//AddInput.js\n\nimport React, { useState } from \"react\";\nimport {View, TextInput, Text, TouchableOpacity} from 'react-native'\n\n\nexport default function AddInput() {\n  const [value, setValue] = useState(\"\");\n\n  const onChangeText = (text) => {\n    setValue(text);\n  };\n\n  return (\n    <View>\n      <View>\n        <TextInput placeholder=\"Add Task...\" onChangeText= \n         {onChangeText} />\n      </View>\n      <TouchableOpacity\n        onPress={() => {\n          alert('button clicked')\n        }}\n      >\n        <Text>Submit</Text>\n      </TouchableOpacity>\n    </View>\n  );\n}\n```\n\nThis gives us a basic form where we write to-do items and a button to add them to the to-do list. Let's give this guy a bit of styling to make it look good. \n\n**styling AddInput.js**\nWe would be using a library called styled-components to style the component. Firstly, we install styled-components\n\n```javascript\nyarn add styled-components\n```\nAfter installing it, we import it into the AddInput.js file so we can be able to use it.\n\n```javascript\n//AddInput.js\n ...\nimport styled from \"styled-components\";\n\n ...\n\n//beneath the AddInput component\n//styles\nconst ComponentContainer = styled.View`\n  flex-direction: row;\n`;\n\nconst InputContainer = styled.View`\n  flex-direction: row;\n  border-radius: 10px;\n`;\n\nconst Input = styled.TextInput`\n  font-size: 20px;\n  background-color: white;\n  width: 300px;\n  margin-right: 20px;\n  padding: 10px;\n  margin-bottom: 20px;\n  border-radius: 10px;\n`;\n\nconst SubmitButton = styled.TouchableOpacity`\n  width: 50px;\n  justify-content: center;\n  align-items: center;\n  background-color: whitesmoke;\n  margin-bottom: 20px;\n  border-radius: 50px;\n`;\n\n ...\n\n```\n\nIn the AddInput component, we would now be updating the native components to custom semantics from styled-components. These native components will now be accessed via styled-components. This is to enable the styling to take place in the AddInput component.\n\n\n```javascript\n ...\n\nexport default function AddInput(}) {\n ...\n  return (\n    <ComponentContainer>\n      <InputContainer>\n        <Input placeholder=\"Add Task...\" onChangeText={onChangeText} />\n      </InputContainer>\n      <SubmitButton\n        onPress={() => {\n           alert('button clicked')\n        }}\n      >\n        <Text>Submit</Text>\n      </SubmitButton>\n    </ComponentContainer>\n  );\n}\n\n//beneath the AddInput component\n//styles\n\n ...\n```\nAs you can see, we updated the native components to a custom-styled component. In this case, we would not need to import these native components from react-native anymore as styled-components already let us access them. \n\nAlright, that's enough for the AddInput.js for now. Let's quickly build up the Empty.js before we continue. The Empty.js file is rendered when the to-do list is empty. This component kind of makes the app look more appealing. \n\n```javascript\nimport React from \"react\";\nimport styled from \"styled-components\";\n\nexport default function Empty() {\n  return (\n    <ComponentContainer>\n      <EmptyImage\n        source={require(\"add an image here\")}\n      />\n      <EmptyText>Add To-Do.</EmptyText>\n    </ComponentContainer>\n  );\n}\n\nconst ComponentContainer = styled.View`\n  align-items: center;\n  justify-content: center;\n  height: 650px;\n`;\n\nconst EmptyImage = styled.Image`\n  width: 350px;\n  height: 200px;\n`;\n\nconst EmptyText = styled.Text`\n  color: white;\n  font-family: poppins-bold;\n  margin-top: 30px;\n  font-size: 30px;\n`;\n\n```\nLet's build what I consider the heartbeat of this app. This will happen in App.js\n\n```javascript\nimport React, { useState } from \"react\";\nimport { View, StatusBar, FlatList } from \"react-native\";\nimport styled from \"styled-components\";\n\n\nexport default function App() {\n const [data, setData] = useState([]);\n return (\n      <ComponentContainer>\n        <View>\n          <StatusBar barStyle=\"light-content\" \n             backgroundColor=\"midnightblue\" />\n        </View>\n\n        <View>\n          <FlatList\n            data={data}\n           renderItem={({ item }) => (\n              console.log(item)\n            )}\n          />\n    \n        </View>\n      </ComponentContainer>\n    );\n}\n\nconst ComponentContainer = styled.View`\n  background-color: midnightblue;\n  height: 100%;\n  flex-direction: column;\n  align-items: center;\n  justify-content: center;\n`;\n\n\n```\n**FlatList**\n\nAt this point, I want to let you know that a to-do list is an array. Let me explain that with something called FlatList. FlatList is a component used to display large scrollable lists. Lists displayed with the FlatList can be infinite and unpredictable. FlatList has two major props which include **data** and the **renderItem**. **data** takes an array, in this case, an array called data which is an empty array and depends on the AddInput component for data to fill up the empty array. This array is the to-do list. On the other hand, we have the **renderItem**  which is a callback function that renders each item of the array of the **data** prop. \n\n##**Adding item to the list**##\n\nLet us go back to our AddInput component and look at one of the native components called TouchableOpacity. This component takes in a prop called onPress. If you check out our above code on AddInput.js, you will see that the onPress prop is set to alert('hi') . onPress runs a function when a button is pressed. Now, the function it will be running is the one that will be adding items to the list(array called data). \n\nIn App.js we will create a method called SubmitHandler, which adds each item to the list. This is the function that will be passed into onPress. \n\n```javascript\n//App.js\n  ...\n\nexport default function App() {\n     ...\n  const submitHandler = (value) => {\n    setData((prevTodo) => {\n      return [\n        {\n          value: value,\n          key: Math.random().toString(),\n        },\n        ...prevTodo,\n      ];\n    });\n\n     ...\n  };\n\n```\nThe submitHandler method holds a function called setData that updates the state by adding items to the array.\n\nTo get the SubmitHandler method to work in the AddInput.js, we need to bring the AddInput component into the App.js and pass the SubmitHandler as a prop to the AddInput component.\n\n```javascript\n//App.js\n ...\nimport AddInput from \"./Components/AddInput\";\n\nexport default function App() {\n   ...\n\n  const submitHandler = (value) => {\n    setData((prevTodo) => {\n      return [\n        {\n          value: value,\n          key: Math.random().toString(),\n        },\n        ...prevTodo,\n      ];\n    });\n  };\n\n  \n    return (\n      <ComponentContainer>\n        <View>\n          <StatusBar barStyle=\"light-content\" \n            backgroundColor=\"midnightblue\" />\n        </View>\n\n        <View>\n          //FlatList\n          <View>\n            <AddInput submitHandler={submitHandler} />\n          </View>\n        </View>\n      </ComponentContainer>\n    );\n```\nThe submitHandler method is passed in as a prop to the AddInput component to be used inside the AddInput component. \n\nBack to AddInput.js, we pass in the props \n```javascript\n  ...\nexport default function AddInput({ submitHandler }){\n   ...\nreturn(\n  ...\n <SubmitButton\n        onPress={() => {\n          setValue(submitHandler(value));\n        }}\n      >\n        ...\n      </SubmitButton>\n)\n}\n```\nHere, we are adding the value from our form input to the array being handled by the **data** prop in App.js with the help of onPress who calls the SubmitHandler function when pressed.\n\n**Displaying list to screen**\n\nAnother component called TodoList is created at this point because we need it to render our to-do list items to the screen. Remember the renderItems prop from FlatList which helps to render items from the data prop to the screen? We are going to use it to render the TodoList component to the screen(this component holds our array items.)\n\nBack to App.js\n```javascript\n  ...\nimport TodoList from \"./Components/TodoList\";\n  ...\n\n<FlatList\n            data={data}\n            renderItem={({ item }) => (\n              <TodoList item={item} />\n            )}\n          />\n```\n\nNow moving to the TodoList.js, we build our component. \n\n```javascript\n//TodoList.js\nimport React from \"react\";\nimport { View } from \"react-native\";\nimport styled from \"styled-components\";\n\nexport default function TodoList({ item }) {\n  return (\n    <ComponentContainer>\n      <ListContainer>\n        <View>\n          <TextItem>{item.value}</TextItem>\n          <TextTask> Task</TextTask>\n        </View>\n      </ListContainer>\n    </ComponentContainer>\n  );\n}\n\nconst ListContainer = styled.TouchableOpacity`\n  background-color: whitesmoke;\n  height: auto;\n  width: 350px;\n  margin-bottom: 30px;\n  border-radius: 10px;\n  flex-direction: row;\n  justify-content: space-between;\n`;\n\nconst ComponentContainer = styled.View`\n  flex-direction: row;\n  justify-content: center;\n  height: auto;\n  width: auto;\n`;\n\nconst TextItem = styled.Text`\n  color: black;\n  width: 260px;\n  height: auto;\n  font-size: 20px;\n  margin-top: 10px;\n  margin-right: 20px;\n  font-family: poppins-regular;\n`;\n\nconst TextTask = styled.Text`\n  color: goldenrod;\n  font-size: 15px;\n  margin-right: 20px;\n  font-family: poppins-regular;\n  border-radius: 10px;\n  width: 40px;\n`;\n\n```\nAt this point, each item of our to-do list should be displayed on the screen when the function in onPress is called. \n\nBefore we continue, we need to make our list of items unique with a key. We do this by employing a prop called the keyExtractor prop in FlatList. This prop assigns a key to each of the items in the list. \n\n```javascript\n  ...\n \n<FlatList\n            data={data}\n            keyExtractor={(item) => item.key}\n            renderItem={({ item }) => (\n              <TodoList item={item} />\n            )}\n          />\n```\n\n\n**Deleting items from list**\n\nTo delete items from the to-do list, we will create a method called DeleteItem in App.js and bring it in as a prop into TodoList.js\n\n```javascript\n//App.js\n  ...\n\nexport default function App() {\n     ...\n  const deleteItem = (key) => {\n    setData((prevTodo) => {\n      return prevTodo.filter((todo) => todo.key != key);\n    });\n  };\n     ...\n  };\n\n\n```\nNow we pass deleteItem as a prop to the TodoList component\n\n```javascript\n//App.js\n  ...\nimport TodoList from \"./Components/TodoList\";\n  ...\n\n<FlatList\n            data={data}\n            keyExtractor={(item) => item.key}\n            renderItem={({ item }) => (\n              <TodoList item={item} deleteItem={deleteItem} />\n            )}\n          />\n```\n\nFor DeleteItem to work in TodoList.js, we need to update the component. \n\n```javascript\nimport React from \"react\";\nimport { View } from \"react-native\";\nimport { Entypo } from \"@expo/vector-icons\";\nimport { MaterialIcons } from \"@expo/vector-icons\";\nimport styled from \"styled-components\";\n\nexport default function TodoList({ item, deleteItem }) {\n  return (\n    <ComponentContainer>\n      <ListContainer>\n        <CirlceContainer>\n          <Entypo name=\"circle\" size={20} color=\"midnightblue\" />\n        </CirlceContainer>\n        <View>\n          <TextItem>{item.value}</TextItem>\n          <TextDate> Task</TextDate>\n        </View>\n        <IconContainer onPress={() => deleteItem(item.key)}>\n          <MaterialIcons name=\"delete\" size={24} color=\"midnightblue\" />\n        </IconContainer>\n      </ListContainer>\n    </ComponentContainer>\n  );\n}\n\nconst ListContainer = styled.TouchableOpacity`\n  background-color: whitesmoke;\n  height: auto;\n  width: 350px;\n  margin-bottom: 30px;\n  border-radius: 10px;\n  flex-direction: row;\n  justify-content: space-between;\n`;\n\nconst ComponentContainer = styled.View`\n  flex-direction: row;\n  justify-content: center;\n  height: auto;\n  width: auto;\n`;\n\nconst TextItem = styled.Text`\n  color: black;\n  width: 260px;\n  height: auto;\n  font-size: 20px;\n  margin-top: 10px;\n  margin-right: 20px;\n  font-family: poppins-regular;\n`;\n\nconst TextDate = styled.Text`\n  color: goldenrod;\n  font-size: 15px;\n  margin-right: 20px;\n\n  font-family: poppins-regular;\n  border-radius: 10px;\n  width: 40px;\n`;\n\nconst IconContainer = styled.TouchableOpacity`\n  align-items: center;\n  justify-content: center;\n  margin-right: 10px;\n  margin-top: 15px;\n\n  height: 40px;\n\n  border-radius: 10px;\n`;\n\nconst CirlceContainer = styled.View`\n  align-items: center;\n  justify-content: center;\n  padding-left: 5px;\n`;\n```\n\nIn the above code, we can delete an item from the list and we use icons to represent the delete button which removes items from the list when pressed.\n\n**Final Touches**\n\nThe FlatList has other props attached to it. but we would focus on two more. These three include: \na. ListHeaderComponent\nb. ListEmptyComponent\n\n\nListHeaderComponent will hold a component that contains the header of the list. Remember our Header.js file? It is time to use it. \n\n```javascript\n//Header.js\n\nimport React from \"react\";\nimport styled from \"styled-components\";\n\nlet today = new Date().toISOString().slice(0, 10);\n\nexport default function Header() {\n  return (\n    <ComponentContainer>\n      <HeaderText>To-Do.</HeaderText>\n      <HeaderList>{today}</HeaderList>\n    </ComponentContainer>\n  );\n}\n\nconst ComponentContainer = styled.View`\n  height: 100px;\n  flex-direction: row;\n  justify-content: space-between;\n  align-items: center;\n`;\n\nconst HeaderText = styled.Text`\n  color: white;\n  font-family: poppins-bold;\n  font-size: 30px;\n`;\n\nconst HeaderList = styled.Text`\n  color: white;\n  font-family: poppins-bold;\n  font-size: 20px;\n  margin-right: 20px;\n`;\n```\nThis component will be at the head of the screen. Let's make some changes to our App.js file.\n\n```javascript\n//App.js\n  ...\nimport Header from \"./Components/Header\";\n  ...\n\n<FlatList\n            data={data}\n            ListHeaderComponent={() => <Header />}\n            keyExtractor={(item) => item.key}\n            renderItem={({ item }) => (\n              <TodoList item={item} deleteItem={deleteItem} />\n            )}\n          />\n```\n\n\nAnother prop is the ListEmptyComponent which renders a component when the to-do list is empty. Here, we are going to pass in the Empty component from Empty.js\n\n```javascript\n//App.js\n  ...\nimport Empty from \"./Components/Empty\";\n  ...\n\n<FlatList\n            data={data}\n            ListHeaderComponent={() => <Header />}\n            ListEmptyComponent={() => <Empty />}\n            keyExtractor={(item) => item.key}\n            renderItem={({ item }) => (\n              <TodoList item={item} deleteItem={deleteItem} />\n            )}\n          />\n```\n**Conclusion**\n\nPheew! That was a lot of code. I hope you practice this and get your hands dirty. It is the best form of learning. I would love to see you tweak the code to your own taste and make something nice out of it. Good Luck in your endeavors and React-Native journey.","hasPolls":false,"totalPollVotes":0,"upvotes":0,"downvotes":0,"tags":["56744722958ef13879b94f4d","56744723958ef13879b95434","56744721958ef13879b94cad","568a9b8ce4c4e23aef243c1f"],"untaggedFrom":[],"upvotedBy":[],"downvotedBy":[],"popularity":4581.9213,"responses":[],"responseCount":0,"replyCount":0,"followers":[],"isActive":true,"isFeatured":false,"isEngaging":false,"answeredByTarget":false,"inviters":[],"isDelisted":false,"isNotified":false,"duplicatePosts":[],"numCollapsed":0,"hasReward":false,"bookmarkedIn":[],"similarPostIds":[],"reactions":["5c090d96c2a9c2a674d35484"],"totalReactions":1,"reactionsByCurrentUser":[],"isPinnedToBlog":false,"disableComments":false,"commentsPaused":false,"hasLatex":true,"syncAlgolia":true,"enableToc":false,"toc":[],"numUniqueUsersWhoReacted":0,"_id":"604909e0258b6d5f4339eed3","title":"Building a To-Do List with React-Native and Styled-Components.","type":"story","isRepublished":true,"originalArticleURL":"https://dev.to/reenydavidson/building-a-to-do-list-with-react-native-and-styled-components-2148","partOfPublication":true,"publication":"5f3c514b2324e0296c44f59e","slug":"building-a-to-do-list-with-react-native-and-styled-components","cuid":"ckm3r38dj028htfs1hxwx9ejr","dateAdded":"2021-03-08T10:00:59.000Z","hasCustomDate":true,"pollOptions":[],"badges":[],"questionReplies":[],"contributors":[],"author":"5f3c4f879584ef298dc17192","followersCount":1,"hasPinnedTag":false,"readTime":16,"__v":1,"series":null,"dateUpdated":"2021-03-10T18:12:05.477Z","pendingPublicationApproval":false,"subtitle":"","viewsUpdatedOn":1639386004232,"reactionToCountMap":{"reaction_5c090d96c2a9c2a674d35484":1},"uniqueReactions":["5c090d96c2a9c2a674d35484"],"reactionToCountMapUnique":{"reaction_5c090d96c2a9c2a674d35484":1},"id":"604909e0258b6d5f4339eed3"},{"reward":{"type":"xlm"},"sourcedFromGithub":false,"isAnonymous":false,"views":105,"slugOverridden":false,"coverImage":"https://cdn.hashnode.com/res/hashnode/image/upload/v1614170513312/2XmE19hi1.jpeg","autoGeneratedCover":"","brief":"Fetching API data with useEffect can be tricky sometimes. In this article, we will look at one trick for efficient data fetching with useEffect. \nThis article assumes you understand how useEffect hook works. If you do not, visit the react docs.\nLet's...","content":"<p>Fetching API data with useEffect can be tricky sometimes. In this article, we will look at one trick for efficient data fetching with useEffect. </p>\n<p><em>This article assumes you understand how useEffect hook works. If you do not, visit <a target=\"_blank\" href=\"https://reactjs.org/docs/hooks-effect.html\">the react docs.</a></em></p>\n<p>Let's begin, shall we?</p>\n<p><strong>setTimeout</strong></p>\n<p>setTimeout is a javascript function that takes in another function or a random code snippet and executes it after a specified period of time(millisecond).</p>\n<pre><code class=\"lang-javascript\"><span class=\"hljs-built_in\">setTimeout</span>(\n  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'You will get this in five seconds egghead.'</span>), \n<span class=\"hljs-number\">5000</span>)\n</code></pre>\n<p>The setTimeout function will execute the console.log() function after five seconds of running the code. </p>\n<pre><code class=\"lang-javascript\"><span class=\"hljs-built_in\">setTimeout</span>(\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Add</span>(<span class=\"hljs-params\">a, b</span>)</span>{\n   <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">4</span>+<span class=\"hljs-number\">7</span>;\n},\n<span class=\"hljs-number\">3000</span>)\n</code></pre>\n<p>Here, we can see that the setTimeout function can take in another function. The Add function inside setTimeout function in this case runs after three seconds of running the code.</p>\n<p>That should very much explain how the setTimeout function works. Let's now look at how we can use it for data fetching with useEffect. </p>\n<p><strong>Data fetching in UseEffect</strong></p>\n<pre><code class=\"lang-javascript\">useEffect(<span class=\"hljs-function\">() =&gt;</span> {\n    <span class=\"hljs-keyword\">const</span> fetchData = <span class=\"hljs-keyword\">async</span> () =&gt; {\n      <span class=\"hljs-keyword\">await</span> fetch(<span class=\"hljs-string\">`https://api.github.com/users/<span class=\"hljs-subst\">${input}</span>`</span>)\n        .then(<span class=\"hljs-function\">(<span class=\"hljs-params\">res</span>) =&gt;</span> res.json())\n        .then(<span class=\"hljs-function\">(<span class=\"hljs-params\">res</span>) =&gt;</span> setData([res]))\n        .catch(<span class=\"hljs-function\">(<span class=\"hljs-params\">e</span>) =&gt;</span> <span class=\"hljs-built_in\">console</span>.error(e));\n    };\n\n   fetchData();\n  }, [input]);\n</code></pre>\n<p>As we can see in the code above, A request will be sent to the github API based on what the user types in the input. But there is a problem with this method of requesting data from API, considering the fact that the search value is being typed in by the user. Let me show you!</p>\n<p><img src=\"https://cdn.hashnode.com/res/hashnode/image/upload/v1614170509410/c6A9wY7dd.png\" alt=\"Alt Text\" /></p>\n<p>If you look at the image above very well, you will see that there is a request to the API on every keypress in the network, which is bad. It is bad because multiple requests are being sent to the API and there are multiple responses too. This is caused by the useEffect function which runs on every state change. Remember that state changes whenever there is a keypress and useEffect runs every time there is a change in state. So every time you click on the keyboard, a request is made to the API.</p>\n<p>Two other problems with this method are:</p>\n<ol>\n<li><p>It slows down the app due to the too many unnecessary and irrelevant request being made to the API and it is prone to error.</p>\n</li>\n<li><p>There is always a limit to the number of request a user can make to the API per hour. So this reduces the number of accurate data you can get from API as so many unnecessary request are eating up the specified number of permitted API request.</p>\n</li>\n</ol>\n<p>Well, we obviously do not want that, so will be using setTimeout to solve the problem of multiple request. Let's go!</p>\n<p><strong>Solution</strong></p>\n<p>The solution to this issue of multiple unnecessary request is very simple. We can solve this by wrapping the fetchData function in a setTimeout function.</p>\n<pre><code class=\"lang-javascript\">useEffect(<span class=\"hljs-function\">() =&gt;</span> {\n    <span class=\"hljs-keyword\">const</span> fetchData = <span class=\"hljs-keyword\">async</span> () =&gt; {\n      <span class=\"hljs-keyword\">await</span> fetch(<span class=\"hljs-string\">`https://api.github.com/users/<span class=\"hljs-subst\">${input}</span>`</span>)\n        .then(<span class=\"hljs-function\">(<span class=\"hljs-params\">res</span>) =&gt;</span> res.json())\n        .then(<span class=\"hljs-function\">(<span class=\"hljs-params\">res</span>) =&gt;</span> setData([res]))\n        .catch(<span class=\"hljs-function\">(<span class=\"hljs-params\">e</span>) =&gt;</span> <span class=\"hljs-built_in\">console</span>.error(e));\n    };\n\n    <span class=\"hljs-keyword\">const</span> timer = <span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-function\">() =&gt;</span> {\n      fetchData();\n    }, <span class=\"hljs-number\">5000</span>);\n\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-function\">() =&gt;</span> <span class=\"hljs-built_in\">clearTimeout</span>(timer);\n  }, [input]);\n</code></pre>\n<p>In the code above, the setTimeout function delays any form of request that would have been made to the API after every keypress for five seconds. This gives user enough time to fully type in the search value. The request will be made after five seconds of no keypress. This is actually better, because it does not send multiple request to the API on every keypress. </p>\n<p><img src=\"https://cdn.hashnode.com/res/hashnode/image/upload/v1614170511410/Ps_ABTNTA.png\" alt=\"Alt Text\" /></p>\n<p>With setTimeout, we can see that only one request is being made to the API and we get only one accurate response. This simple practice can improve the speed of the app and its performance too as it does not overload the network with multiple irrelevant requests.</p>\n<p>With that being said, I want to believe that you will be using setTimeout in your next API call when the request involves an input value, to avoid unnecessary requests and responses. Good Luck!</p>\n","contentMarkdown":"Fetching API data with useEffect can be tricky sometimes. In this article, we will look at one trick for efficient data fetching with useEffect. \n\n*This article assumes you understand how useEffect hook works. If you do not, visit [the react docs.](https://reactjs.org/docs/hooks-effect.html)*\n\nLet's begin, shall we?\n\n**setTimeout**\n\nsetTimeout is a javascript function that takes in another function or a random code snippet and executes it after a specified period of time(millisecond).\n\n```javascript\nsetTimeout(\n  console.log('You will get this in five seconds egghead.'), \n5000)\n\n```\nThe setTimeout function will execute the console.log() function after five seconds of running the code. \n\n\n\n```javascript\nsetTimeout(\n  function Add(a, b){\n   return 4+7;\n},\n3000)\n```\n\nHere, we can see that the setTimeout function can take in another function. The Add function inside setTimeout function in this case runs after three seconds of running the code.\n\nThat should very much explain how the setTimeout function works. Let's now look at how we can use it for data fetching with useEffect. \n\n**Data fetching in UseEffect**\n\n\n```javascript\nuseEffect(() => {\n    const fetchData = async () => {\n      await fetch(`https://api.github.com/users/${input}`)\n        .then((res) => res.json())\n        .then((res) => setData([res]))\n        .catch((e) => console.error(e));\n    };\n\n   fetchData();\n  }, [input]);\n```\n\nAs we can see in the code above, A request will be sent to the github API based on what the user types in the input. But there is a problem with this method of requesting data from API, considering the fact that the search value is being typed in by the user. Let me show you!\n\n\n\n![Alt Text](https://cdn.hashnode.com/res/hashnode/image/upload/v1614170509410/c6A9wY7dd.png)\n\n\nIf you look at the image above very well, you will see that there is a request to the API on every keypress in the network, which is bad. It is bad because multiple requests are being sent to the API and there are multiple responses too. This is caused by the useEffect function which runs on every state change. Remember that state changes whenever there is a keypress and useEffect runs every time there is a change in state. So every time you click on the keyboard, a request is made to the API.\n\nTwo other problems with this method are:\n\n1. It slows down the app due to the too many unnecessary and irrelevant request being made to the API and it is prone to error.\n\n2. There is always a limit to the number of request a user can make to the API per hour. So this reduces the number of accurate data you can get from API as so many unnecessary request are eating up the specified number of permitted API request.\n\nWell, we obviously do not want that, so will be using setTimeout to solve the problem of multiple request. Let's go!\n\n**Solution**\n\nThe solution to this issue of multiple unnecessary request is very simple. We can solve this by wrapping the fetchData function in a setTimeout function.\n\n```javascript\nuseEffect(() => {\n    const fetchData = async () => {\n      await fetch(`https://api.github.com/users/${input}`)\n        .then((res) => res.json())\n        .then((res) => setData([res]))\n        .catch((e) => console.error(e));\n    };\n\n    const timer = setTimeout(() => {\n      fetchData();\n    }, 5000);\n\n    return () => clearTimeout(timer);\n  }, [input]);\n```\nIn the code above, the setTimeout function delays any form of request that would have been made to the API after every keypress for five seconds. This gives user enough time to fully type in the search value. The request will be made after five seconds of no keypress. This is actually better, because it does not send multiple request to the API on every keypress. \n\n\n![Alt Text](https://cdn.hashnode.com/res/hashnode/image/upload/v1614170511410/Ps_ABTNTA.png)\n\n\nWith setTimeout, we can see that only one request is being made to the API and we get only one accurate response. This simple practice can improve the speed of the app and its performance too as it does not overload the network with multiple irrelevant requests.\n\nWith that being said, I want to believe that you will be using setTimeout in your next API call when the request involves an input value, to avoid unnecessary requests and responses. Good Luck!\n\n\n\n\n\n\n  ","hasPolls":false,"totalPollVotes":0,"upvotes":0,"downvotes":0,"tags":["56744723958ef13879b95434","56744721958ef13879b94cad","56744722958ef13879b94f1b","56744723958ef13879b955a9"],"untaggedFrom":[],"upvotedBy":[],"downvotedBy":[],"popularity":4514.0478,"responses":[],"responseCount":0,"replyCount":0,"followers":[],"isActive":true,"isFeatured":false,"isEngaging":false,"answeredByTarget":false,"inviters":[],"isDelisted":false,"isNotified":false,"duplicatePosts":[],"numCollapsed":0,"hasReward":false,"bookmarkedIn":[],"similarPostIds":[],"reactions":[],"totalReactions":0,"reactionsByCurrentUser":[],"isPinnedToBlog":false,"disableComments":false,"commentsPaused":false,"hasLatex":true,"syncAlgolia":false,"enableToc":false,"toc":[],"numUniqueUsersWhoReacted":0,"_id":"6036499305efef7f0a9d34d1","title":"setTimeOut in useEffect API call (Data Fetching).","type":"story","isRepublished":true,"originalArticleURL":"https://dev.to/reenydavidson/settimeout-in-useeffect-api-call-data-fetching-j33","partOfPublication":true,"publication":"5f3c514b2324e0296c44f59e","slug":"settimeout-in-useeffect-api-call-data-fetching","cuid":"ckljfg4zf015e3es16fvi5eyt","dateAdded":"2021-02-01T01:35:53.000Z","hasCustomDate":true,"pollOptions":[],"badges":[],"questionReplies":[],"contributors":[],"author":"5f3c4f879584ef298dc17192","followersCount":1,"hasPinnedTag":false,"readTime":6,"__v":1,"series":null,"dateUpdated":"2021-02-24T12:51:13.140Z","pendingPublicationApproval":false,"subtitle":"","reactionToCountMap":{"reaction_5c090d96c2a9c2a674d35485":0,"reaction_5c090d96c2a9c2a674d35484":0},"viewsUpdatedOn":1639513804241,"uniqueReactions":[],"reactionToCountMapUnique":{"reaction_5c090d96c2a9c2a674d35485":0,"reaction_5c090d96c2a9c2a674d35484":0},"id":"6036499305efef7f0a9d34d1"},{"reward":{"type":"xlm"},"sourcedFromGithub":false,"isAnonymous":false,"views":100,"slugOverridden":false,"coverImage":"https://cdn.hashnode.com/res/hashnode/image/upload/v1597794631165/JW2wMFj5o.png","autoGeneratedCover":"","brief":"React is a frontend UI library for designing user interfaces of web applications.\nWhen writing a React application, it is very necessary you understand the concept of React components and what they actually do. React has made these components very ea...","content":"<p>React is a frontend UI library for designing user interfaces of web applications.</p>\n<p>When writing a React application, it is very necessary you understand the concept of React components and what they actually do. React has made these components very easy to create and very much reusable in any case.</p>\n<p>Now lets jump into Components, shall we?</p>\n<h1 id=\"-what-are-react-components-\"><strong>What are React Components?</strong></h1>\n<p>React components are independent units that make up a React app. It can also be seen as building blocks that evaluates to a full React application. You would definitely be using components a lot, trust me. In fact, you cannot build a React application without creating components, its impossible. Imagine building a house without blocks or building a car without its various parts, that is very impossible. These components must be put together to build a React application. They make up different part of the UI and also let you control all these parts independently.</p>\n<pre><code><span class=\"hljs-keyword\">const</span> myFirstComponent = <span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> &lt;h1&gt;Yes! I wrote a component&lt;<span class=\"hljs-regexp\">/h1&gt;</span>\n</code></pre><p>The above is a very simple function component that will display the <strong>h1</strong> child to the browser. Mind you, the element that is being returned by the component above is not HTML. It is called JSX. Visit <em>https://reactjs.org/docs/introducing-jsx.html</em> for better understanding of JSX</p>\n<hr />\n<h1 id=\"types-of-components\">Types of Components</h1>\n<p>In React, there are basically two types of components. These two types of components are:</p>\n<ol>\n<li>Class components</li>\n<li>Functional components</li>\n</ol>\n<p><em>I will start by explaining the class component.</em></p>\n<h2 id=\"class-components-stateful-\">Class Components (stateful)</h2>\n<p>The class component is said to be <strong><em>stateful</em></strong> as it tends to implement some kind of logic and also manage any local state in the component. It also accepts lifecycle methods.</p>\n<pre><code>import React from \"react\";\n\nconst FunctionComponent = (props) =&gt; {\n  return (\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">form</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">placeholder</span>=<span class=\"hljs-string\">\"Enter Term...\"</span> /&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span>&gt;</span>Submit<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">form</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h1</span>&gt;</span>{props.message}<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n  );\n};\n\nexport default FunctionComponent;\n</code></pre><p><em>A simple class component in react.</em></p>\n<hr />\n<h2 id=\"state\">state</h2>\n<p>React state can be seen as an instance of properties that affects the behavior of the UI when rendered to the browser. It handles data that changes overtime, which means it is mutable. The state is basically an object that holds some kind of data that affects the UI at anytime. This state can only be written in a class component.</p>\n<pre><code><span class=\"hljs-keyword\">import</span> React, { Component } from <span class=\"hljs-string\">\"react\"</span>;\n\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">App</span> <span class=\"hljs-title\">extends</span> <span class=\"hljs-title\">Component</span> </span>{\n  state={firstname:<span class=\"hljs-string\">''</span>, lastname:<span class=\"hljs-string\">''</span>}\n\n  render(){\n    <span class=\"hljs-keyword\">return</span> (\n      &lt;div&gt;\n      &lt;form&gt;\n        &lt;input\n          placeholder=<span class=\"hljs-string\">'firstname'</span>\n          value={<span class=\"hljs-keyword\">this</span>.state.firstname}\n          onChange={(e)=&gt;{<span class=\"hljs-keyword\">this</span>.setState({firstname:e.target.value})}}\n        /&gt;\n         &lt;input\n          placeholder=<span class=\"hljs-string\">'lasttname'</span>\n          value={<span class=\"hljs-keyword\">this</span>.state.lastname}\n          onChange={(e)=&gt;{<span class=\"hljs-keyword\">this</span>.setState({lastname:e.target.value})}}\n        /&gt;\n        &lt;button onClick={(e)=&gt;{e.preventDefault()}}&gt;click&lt;/button&gt;\n      &lt;/form&gt;\n\n&lt;/div&gt;\n    )\n  }\n}\n\nexport <span class=\"hljs-keyword\">default</span> App\n</code></pre><p><em>A class component with state.</em></p>\n<p>The above code shows that on every keypress on the form input, the component re-renders and changes the UI state.</p>\n<p><strong>Lifecycle methods</strong></p>\n<p>Lifecycle methods simply explains the all round period of the component from when it was rendered to when it was destroyed, probably as a result of leaving page or deleting something. Just like a cooking process or lifecycle, components has its own lifecycle. The three major ones are:</p>\n<ol>\n<li>When the component mounts</li>\n<li>When the component updates</li>\n<li>When the component unmounts.</li>\n</ol>\n<p><strong>componentDidMount</strong></p>\n<p>This method is called once. It is fired immediately the component has been rendered. You can use this method to fetch data from an API and also render the data after the component has been mounted. You can use it to fetch any information or data you want to have immediately the component is rendered.</p>\n<pre><code>componentDidMount() {\n       <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'I run immediately the component is rendered'</span>)\n  }\n</code></pre><p>The above code will log I run immediately the component is rendered to the console immediately the component is rendered.</p>\n<p><strong>componentDidUpdate</strong></p>\n<p>This method is called when theres a change in the state of a rendered component. This method accepts two arguments which are the previous props and the previous state.</p>\n<pre><code>componentDidUpdate(prevProps, prevState) {\n  <span class=\"hljs-keyword\">if</span> (prevState.colors !== <span class=\"hljs-keyword\">this</span>.state.colors) {\n    console.log(<span class=\"hljs-string\">'colors has changed.'</span>)\n  }\n}\n</code></pre><p>Basically, componentDidUpdate is called based on a condition that is to be met, which is a comparison between the previous state and current state. If there is a change from previous state to current state, the method will run, but if no change has occurred in the state, the method wont be called.</p>\n<p><strong>componentWillUnmount</strong></p>\n<p>This method is called when the component is being removed from the DOM. It is the last method you call in a components lifecycle. Basically, you call this guy to run immediately before the component is destroyed and in this method, you can do some cleanup that regards to the component before it unmounts.</p>\n<pre><code>componentWillUnmount(){\n    alert(<span class=\"hljs-string\">'This component is about to be unmounted.'</span>);\n}\n</code></pre><p>In the above snip, we can see that the user is getting a warning from componentWillUnmount before the component is destroyed. Basically, componentWillUnmount holds the activity that will be carried before the component is dismantled from the DOM.</p>\n<h2 id=\"-functional-components-i-am-without-state-\"><strong>Functional Components (I am without state)</strong></h2>\n<p>Also known as <strong><em>stateless</em></strong> component is a component that only takes in props and renders elements (JSX) to the UI. A functional component cannot manage state, making it impossible for it to implement any form of logic that might affect the state of the UI being rendered. It is basically a Javascript function returning an element.</p>\n<pre><code>import React from \"react\";\n\nconst FunctionComponent = (props) =&gt; {\n  return (\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">form</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">placeholder</span>=<span class=\"hljs-string\">\"Enter Term...\"</span> /&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span>&gt;</span>Submit<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">form</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h1</span>&gt;</span>{props.message}<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n  );\n};\n\nexport default FunctionComponent;\n</code></pre><p><em>Function Component in React.</em></p>\n<p>The code above shows a function component that takes in an input element and a props which is basically passing information from another component. Apart from the fact that a function component returns JSX and accepts props, We can also say that function component is used only when we have no plan to make use of state and lifecycle methods in the component. <strong>BUT!</strong> lets not write this guy off yet, he has his own super powers which he uses to effect changes to the UI.</p>\n<p>Function component uses what is known as <strong>Hooks</strong> to effect changes to UI. Hooks lets you hook into React state in a function component with <strong>useState</strong> and also tap into lifecycle method with <strong>useEffect</strong>. Hooks makes it possible for logic to be applied in a function component. It is a very important tool in React function components.</p>\n<h2 id=\"usestate\">UseState</h2>\n<p>UseState hook basically does in function component what a state and setState would do in class component, which is manipulating the UI.</p>\n<pre><code>import React <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"react\"</span>;\n\n<span class=\"hljs-keyword\">const</span> FunctionalInput = () =&gt; {\n  <span class=\"hljs-keyword\">const</span> [state, setstate] = React.useState({ firstname: <span class=\"hljs-string\">\"\"</span>, lastname: <span class=\"hljs-string\">\"\"</span> });\n  <span class=\"hljs-keyword\">const</span> handleClick = (e) =&gt; {\n    setstate(e.target.<span class=\"hljs-keyword\">value</span>);\n    console.log(e.target.<span class=\"hljs-keyword\">value</span>);\n  };\n\n  <span class=\"hljs-keyword\">return</span> (\n    &lt;div&gt;\n      &lt;input\n        <span class=\"hljs-keyword\">value</span>={state.firstname}\n        onChange={handleClick}\n        placeholder=<span class=\"hljs-string\">\"firstname\"</span>\n      /&gt;\n      &lt;input\n        <span class=\"hljs-keyword\">value</span>={state.lastname}\n        onChange={handleClick}\n        placeholder=<span class=\"hljs-string\">\"lastname\"</span>\n      /&gt;\n    &lt;/div&gt;\n  );\n};\n\nexport <span class=\"hljs-keyword\">default</span> FunctionalInput;\n</code></pre><p><em>use of useState in a function component</em></p>\n<p>The code above shows how React uses useState to manage state in a function component. In the array destructuring seen above, state is the initial condition of the UI and we need to update that at every keypress made in the input element which re-renders the UI and also changes the state of the UI at every re-render. I came to realize that useState does a better job at managing state (just my opinion). I believe so because it just use less code to do the same thing that the class component does with setState.</p>\n<h2 id=\"-useeffect-\"><strong>useEffect</strong></h2>\n<p>Another hook we will look at is the useEffect hook. It has some kind of similarity with the the lifecycle methods of the class component. This hook is basically a function that holds another function that will run after the the UI has been rendered, just like componentDidMount would do. It also does it with less code, unlike lifecycle methods that involves componentDidMount, componentDidUpdate and componentWillUnmount just to do what only useEffect will do.</p>\n<pre><code>import React, { useEffect } from <span class=\"hljs-string\">\"react\"</span>;\n\nconst FunctionalInput = <span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> {\n  const [state, setstate] = React.useState({ firstname: <span class=\"hljs-string\">\"\"</span>, lastname: <span class=\"hljs-string\">\"\"</span> });\n\n  <span class=\"hljs-regexp\">//</span>This piece <span class=\"hljs-keyword\">of</span> code runs after the ui has been rendered\n  useEffect(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> {\n    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">\"A component was rendered!!!\"</span>);\n  }, []);\n\n  const handleClick = <span class=\"hljs-function\"><span class=\"hljs-params\">(e)</span> =&gt;</span> {\n    setstate(e.target.value);\n    <span class=\"hljs-built_in\">console</span>.log(e.target.value);\n  };\n\n  <span class=\"hljs-keyword\">return</span> (\n    &lt;div&gt;\n      &lt;input\n        value={state.firstname}\n        onChange={handleClick}\n        placeholder=<span class=\"hljs-string\">\"firstname\"</span>\n      /&gt;\n      &lt;input\n        value={state.lastname}\n        onChange={handleClick}\n        placeholder=<span class=\"hljs-string\">\"lastname\"</span>\n      /&gt;\n    &lt;/div&gt;\n  );\n};\n\nexport default FunctionalInput;\n</code></pre><p><em>use of useEffect in a function component</em></p>\n<p>useEffect here will run immediately the UI is rendered. The array at the end makes it run once and never run again at every re-render, but without the array, useEffect continues to run each time the UI re-renders. An API can also be fetched with useEffect hook. When the UI renders, the useEffect is triggered, which allows the API to retrieve any form of data it is meant to retrieve.</p>\n<p>In React, you can create your own custom hooks, which gives you the freedom to use hooks as you please. Note that React Hooks can only be used in React function component.</p>\n<p>These two components mentioned in this article can be used, based on what you are building. Its very necessary you learn how to use the two of them as a React developer.</p>\n<p>With that being said, go and React!</p>\n","contentMarkdown":"\nReact is a frontend UI library for designing user interfaces of web applications.\n\nWhen writing a React application, it is very necessary you understand the concept of React components and what they actually do. React has made these components very easy to create and very much reusable in any case.\n\nNow lets jump into Components, shall we?\n\n\n\n# **What are React Components?**\n\nReact components are independent units that make up a React app. It can also be seen as building blocks that evaluates to a full React application. You would definitely be using components a lot, trust me. In fact, you cannot build a React application without creating components, its impossible. Imagine building a house without blocks or building a car without its various parts, that is very impossible. These components must be put together to build a React application. They make up different part of the UI and also let you control all these parts independently.\n\n\n```\nconst myFirstComponent = () => <h1>Yes! I wrote a component</h1>\n```\n\n\nThe above is a very simple function component that will display the **h1** child to the browser. Mind you, the element that is being returned by the component above is not HTML. It is called JSX. Visit _https://reactjs.org/docs/introducing-jsx.html_ for better understanding of JSX\n\n* * *\n\n# Types of Components\n\nIn React, there are basically two types of components. These two types of components are:\n\n1.  Class components\n2.  Functional components\n\n_I will start by explaining the class component._\n\n## Class Components (stateful)\n\nThe class component is said to be **_stateful_** as it tends to implement some kind of logic and also manage any local state in the component. It also accepts lifecycle methods.\n\n```\nimport React from \"react\";\n\nconst FunctionComponent = (props) => {\n  return (\n    <div>\n      <form>\n        <input placeholder=\"Enter Term...\" />\n        <button>Submit</button>\n      </form>\n      <div>\n        <h1>{props.message}</h1>\n      </div>\n    </div>\n  );\n};\n\nexport default FunctionComponent;\n```\n*A simple class component in react.*\n\n* * *\n\n## state\n\nReact state can be seen as an instance of properties that affects the behavior of the UI when rendered to the browser. It handles data that changes overtime, which means it is mutable. The state is basically an object that holds some kind of data that affects the UI at anytime. This state can only be written in a class component.\n\n```\nimport React, { Component } from \"react\";\n\nclass App extends Component {\n  state={firstname:'', lastname:''}\n\n  render(){\n    return (\n      <div>\n      <form>\n        <input\n          placeholder='firstname'\n          value={this.state.firstname}\n          onChange={(e)=>{this.setState({firstname:e.target.value})}}\n        />\n         <input\n          placeholder='lasttname'\n          value={this.state.lastname}\n          onChange={(e)=>{this.setState({lastname:e.target.value})}}\n        />\n        <button onClick={(e)=>{e.preventDefault()}}>click</button>\n      </form>\n      \n</div>\n    )\n  }\n}\n\nexport default App\n```\n*A class component with state.*\n\nThe above code shows that on every keypress on the form input, the component re-renders and changes the UI state.\n\n**Lifecycle methods**\n\nLifecycle methods simply explains the all round period of the component from when it was rendered to when it was destroyed, probably as a result of leaving page or deleting something. Just like a cooking process or lifecycle, components has its own lifecycle. The three major ones are:\n\n1.  When the component mounts\n2.  When the component updates\n3.  When the component unmounts.\n\n**componentDidMount**\n\nThis method is called once. It is fired immediately the component has been rendered. You can use this method to fetch data from an API and also render the data after the component has been mounted. You can use it to fetch any information or data you want to have immediately the component is rendered.\n\n\n```\ncomponentDidMount() {\n       console.log('I run immediately the component is rendered')\n  }\n```\n\n\nThe above code will log I run immediately the component is rendered to the console immediately the component is rendered.\n\n**componentDidUpdate**\n\nThis method is called when theres a change in the state of a rendered component. This method accepts two arguments which are the previous props and the previous state.\n\n\n```\ncomponentDidUpdate(prevProps, prevState) {\n  if (prevState.colors !== this.state.colors) {\n    console.log('colors has changed.')\n  }\n}\n```\n\n\nBasically, componentDidUpdate is called based on a condition that is to be met, which is a comparison between the previous state and current state. If there is a change from previous state to current state, the method will run, but if no change has occurred in the state, the method wont be called.\n\n**componentWillUnmount**\n\nThis method is called when the component is being removed from the DOM. It is the last method you call in a components lifecycle. Basically, you call this guy to run immediately before the component is destroyed and in this method, you can do some cleanup that regards to the component before it unmounts.\n\n\n```\ncomponentWillUnmount(){\n    alert('This component is about to be unmounted.');\n}\n```\n\n\nIn the above snip, we can see that the user is getting a warning from componentWillUnmount before the component is destroyed. Basically, componentWillUnmount holds the activity that will be carried before the component is dismantled from the DOM.\n\n## **Functional Components (I am without state)**\n\nAlso known as **_stateless_** component is a component that only takes in props and renders elements (JSX) to the UI. A functional component cannot manage state, making it impossible for it to implement any form of logic that might affect the state of the UI being rendered. It is basically a Javascript function returning an element.\n\n```\nimport React from \"react\";\n\nconst FunctionComponent = (props) => {\n  return (\n    <div>\n      <form>\n        <input placeholder=\"Enter Term...\" />\n        <button>Submit</button>\n      </form>\n      <div>\n        <h1>{props.message}</h1>\n      </div>\n    </div>\n  );\n};\n\nexport default FunctionComponent;\n```\n*Function Component in React.*\n\nThe code above shows a function component that takes in an input element and a props which is basically passing information from another component. Apart from the fact that a function component returns JSX and accepts props, We can also say that function component is used only when we have no plan to make use of state and lifecycle methods in the component. **BUT!** lets not write this guy off yet, he has his own super powers which he uses to effect changes to the UI.\n\nFunction component uses what is known as **Hooks** to effect changes to UI. Hooks lets you hook into React state in a function component with **useState** and also tap into lifecycle method with **useEffect**. Hooks makes it possible for logic to be applied in a function component. It is a very important tool in React function components.\n\n## UseState\n\nUseState hook basically does in function component what a state and setState would do in class component, which is manipulating the UI.\n\n```\nimport React from \"react\";\n\nconst FunctionalInput = () => {\n  const [state, setstate] = React.useState({ firstname: \"\", lastname: \"\" });\n  const handleClick = (e) => {\n    setstate(e.target.value);\n    console.log(e.target.value);\n  };\n\n  return (\n    <div>\n      <input\n        value={state.firstname}\n        onChange={handleClick}\n        placeholder=\"firstname\"\n      />\n      <input\n        value={state.lastname}\n        onChange={handleClick}\n        placeholder=\"lastname\"\n      />\n    </div>\n  );\n};\n\nexport default FunctionalInput;\n```\n*use of useState in a function component*\n\nThe code above shows how React uses useState to manage state in a function component. In the array destructuring seen above, state is the initial condition of the UI and we need to update that at every keypress made in the input element which re-renders the UI and also changes the state of the UI at every re-render. I came to realize that useState does a better job at managing state (just my opinion). I believe so because it just use less code to do the same thing that the class component does with setState.\n\n## **useEffect**\n\nAnother hook we will look at is the useEffect hook. It has some kind of similarity with the the lifecycle methods of the class component. This hook is basically a function that holds another function that will run after the the UI has been rendered, just like componentDidMount would do. It also does it with less code, unlike lifecycle methods that involves componentDidMount, componentDidUpdate and componentWillUnmount just to do what only useEffect will do.\n\n```\nimport React, { useEffect } from \"react\";\n\nconst FunctionalInput = () => {\n  const [state, setstate] = React.useState({ firstname: \"\", lastname: \"\" });\n\n  //This piece of code runs after the ui has been rendered\n  useEffect(() => {\n    console.log(\"A component was rendered!!!\");\n  }, []);\n\n  const handleClick = (e) => {\n    setstate(e.target.value);\n    console.log(e.target.value);\n  };\n\n  return (\n    <div>\n      <input\n        value={state.firstname}\n        onChange={handleClick}\n        placeholder=\"firstname\"\n      />\n      <input\n        value={state.lastname}\n        onChange={handleClick}\n        placeholder=\"lastname\"\n      />\n    </div>\n  );\n};\n\nexport default FunctionalInput;\n```\n*use of useEffect in a function component*\n\nuseEffect here will run immediately the UI is rendered. The array at the end makes it run once and never run again at every re-render, but without the array, useEffect continues to run each time the UI re-renders. An API can also be fetched with useEffect hook. When the UI renders, the useEffect is triggered, which allows the API to retrieve any form of data it is meant to retrieve.\n\nIn React, you can create your own custom hooks, which gives you the freedom to use hooks as you please. Note that React Hooks can only be used in React function component.\n\nThese two components mentioned in this article can be used, based on what you are building. Its very necessary you learn how to use the two of them as a React developer.\n\nWith that being said, go and React!","hasPolls":false,"totalPollVotes":0,"upvotes":0,"downvotes":0,"tags":["56744723958ef13879b95434","56744721958ef13879b94cad","56744722958ef13879b94f1b"],"untaggedFrom":[],"upvotedBy":[],"downvotedBy":[],"popularity":4196.2253,"responses":[],"responseCount":0,"replyCount":0,"followers":[],"isActive":true,"isFeatured":false,"isEngaging":false,"answeredByTarget":false,"inviters":[],"isDelisted":false,"isNotified":false,"duplicatePosts":[],"numCollapsed":0,"hasReward":false,"bookmarkedIn":[],"similarPostIds":[],"reactions":["5c090d96c2a9c2a674d35485","5c090d96c2a9c2a674d35484","5c090d96c2a9c2a674d35486","567453d0b73d6a82ac8c5abd","567453d0b73d6a82ac8c5abc","567453d0b73d6a82ac8c5ab9","5c090d96c2a9c2a674d35488","5c090d96c2a9c2a674d3548a","5d9dd859f31791c942dc5b52","5c090d96c2a9c2a674d3548b"],"totalReactions":21,"reactionsByCurrentUser":[],"isPinnedToBlog":false,"disableComments":false,"commentsPaused":false,"hasLatex":false,"syncAlgolia":false,"enableToc":false,"toc":[],"numUniqueUsersWhoReacted":0,"_id":"5f3c62069584ef298dc171d5","title":"Understanding React Components.","type":"story","partOfPublication":true,"publication":"5f3c514b2324e0296c44f59e","slug":"understanding-react-components","cuid":"21b431ce342","importedFromMedium":true,"pollOptions":[],"dateAdded":"2020-08-18T23:19:34.329Z","questionReplies":[],"contributors":[],"author":"5f3c4f879584ef298dc17192","followersCount":1,"draft":"5f3c56409584ef298dc171b9","isRepublished":false,"hasPinnedTag":false,"readTime":10,"__v":1,"reactionToCountMap":{"reaction_5c090d96c2a9c2a674d35485":3,"reaction_5c090d96c2a9c2a674d35484":2,"reaction_5c090d96c2a9c2a674d35486":2,"reaction_567453d0b73d6a82ac8c5abd":2,"reaction_567453d0b73d6a82ac8c5abc":2,"reaction_567453d0b73d6a82ac8c5ab9":2,"reaction_5c090d96c2a9c2a674d35488":2,"reaction_5c090d96c2a9c2a674d3548a":2,"reaction_5d9dd859f31791c942dc5b52":2,"reaction_5c090d96c2a9c2a674d3548b":2},"series":null,"dateUpdated":"2020-08-18T23:53:46.095Z","pendingPublicationApproval":false,"badges":[],"uniqueReactions":["5c090d96c2a9c2a674d35485","5c090d96c2a9c2a674d35484","5c090d96c2a9c2a674d35486","567453d0b73d6a82ac8c5abd","567453d0b73d6a82ac8c5abc","567453d0b73d6a82ac8c5ab9","5c090d96c2a9c2a674d35488","5c090d96c2a9c2a674d3548a","5d9dd859f31791c942dc5b52","5c090d96c2a9c2a674d3548b"],"reactionToCountMapUnique":{"reaction_5c090d96c2a9c2a674d35485":3,"reaction_5c090d96c2a9c2a674d35484":2,"reaction_5c090d96c2a9c2a674d35486":2,"reaction_567453d0b73d6a82ac8c5abd":2,"reaction_567453d0b73d6a82ac8c5abc":2,"reaction_567453d0b73d6a82ac8c5ab9":2,"reaction_5c090d96c2a9c2a674d35488":2,"reaction_5c090d96c2a9c2a674d3548a":2,"reaction_5d9dd859f31791c942dc5b52":2,"reaction_5c090d96c2a9c2a674d3548b":2},"id":"5f3c62069584ef298dc171d5"}]}